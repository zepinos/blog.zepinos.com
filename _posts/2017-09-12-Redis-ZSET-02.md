---
layout: post
title: Spring Boot 와 Redis ZSET 을 이용한 랭킹(리더보드) 구현 - 02
author: zepinos
comments: true
category: Java
cover:  "/assets/instacode.png"
---

Redis 을 이용하면 쉽게 랭킹(리더보드)을 구현할 수 있습니다.

앞선 예제에서 봤듯이 socre 와 사용자를 구분할 수 있는 특정한 값(보통은 ID)을 value 로 하여 값을 등록하면 key 내에서 랭킹 정보를 쉽게 추출할 수 있습니다. 그게 오름차순이든 내림차순이든지 말이죠.

하지만, 단순히 이렇게 구현만 하면 해결이 되는 걸까요?

# 랭킹(리더보드)의 특성

현실 세계에서 ZSET 을 그냥 이용하기에는 약간의 문제가 있습니다. ZSET 의 잘못이라기 보다는 현실 세계의 복잡성 때문이라고 할 수 있습니다. 어떠한 것이 문제인지 다음에서 살펴보도록 하겠습니다.

## 점수 중복

보통 랭킹을 집계하다 보면 동일한 점수가 중복되어 등록될 가능성이 큽니다. 당장 스포츠에서도 많이 볼 수 있는데, 골프만 하더라도 선수들의 점수와 순위가 *몇 언더파로 공동 몇 위* 라는 식으로 표시됩니다. 여기서 *몇 언더파* 라고 하는 것이 점수에 해당하고 *공동 몇 위* 라고 하는 것이 순위에 해당합니다. 혹은 해당 점수를 우선적으로 달성한 사람이 더 앞선 순위로 표시하는 경우도 존재할 것입니다.

그런데, 아쉽게도 Redis 는 score 가 중복적으로 입력이 가능하지만, 순위를 동일하게 부여하지 않습니다. 또한 동일 점수에 대해서 우선 등록 순서에 따라서 순위를 부여하지도 않습니다.

앞에서 언급하지 않았지만, score 가 동점일 경우에는 **value** 순서대로 다시 순서를 정합니다. 입력된 시간이 기준일 것이라고 생각했을 수도 있겠지만, 그렇지 않습니다.

### 공동 순위

Redis ZSET 자체로는 공동 순위를 표시할 수 없습니다. 아쉽게도 공동 순위를 사용하고 싶다면 후처리가 필요합니다.

Redis ZSET 에서 공동 순위를 표시하기 위해 사용할 수 있는 기법은 [ZRANGEBYSCORE](https://redis.io/commands/zrevrangebyscore "Redis ZRANGEBYSCORE") 입니다. ZSetOperations 에서는 `.rangeByScore()` 로 제공됩니다(물론 역순을 위한 것도 준비되어 있습니다).

방법은 간단합니다.
 - 순위 목록을 검색
 - 목록을 이용해 loop 로 개별의 *tuple* 을 획득하여 **score** 를 알아냄
 - **score** 을 이용해 `.rangeByScore()` 에서 해당 점수 중 가장 순위가 높은 **value** 획득
 - 가장 순위가 높은 **value** 을 이용해 **rank** 획득

다만, 이렇게 구현하면 동점자가 리스트 범위 밖에도 있을 경우 한번에 동점자를 동시에 볼 수 없는 문제가 발생합니다. 이 부분은 또다시 여러가지 방법으로 해결할 방법을 고려해야 하기 때문에 여기서 언급하진 않겠습니다. 하지만, 조금만 생각해보시면 금방 해결할 수 있을꺼라 생각됩니다.

### 등록시간 기준

Redis 에서는 score 가 같을 경우 value 순서대로 정렬을 하게 됩니다. 그래서 등록시간 기준으로 동점자를 처리하고자 할 때에는 value 에 등록시간을 입력해주는 방법을 이용할 수도 있습니다.

Java 에서는 시스템 시간을 `System.currentTimeMillis()` 와 같은 명령으로 *long* 형태로 가져올 수 있습니다. 이 값을 기존 value 와 결합하면 value 를 이용해서도 두번째 정렬 기준을 이용할 수 있습니다. 물론 구분자를 통해 세번째 이상의 정렬 기준도 만들어 줄 수 있습니다.

~~~
1505202213287_zepinos
~~~

하지만, 보통의 경우에는 score 가 높은 것이 상위로 표시되도록(즉, 내림차순) 랭킹(리더보드)을 구현하는게 보통입니다. 그리고 먼저 달성한 사람이 우선일 수도 있고, 나중에 달성한 사람이 우선일 수도 있습니다.

이 경우 *long* 으로 값을 얻을 수 있다는 것에 착안하여, `Long.MAX_VALUE` 에서 차감한 값을 사용하는 방법을 고려해볼 수 있습니다. 마치 아래와 같이요.

~~~
9223370531652562520_zepinos
~~~

주의할 것은 *long* 은 숫자인데 반해, value 는 위와 같이 String 으로 정의할 경우 문자 형태로 정렬을 하기 때문에 자릿수가 올라가는 시점에서 정렬이 제대로 되지 않을 수 있습니다. 그래서 처음의 경우처럼 그냥 시스템 시간에 대한 long 값을 쓰는 것보다 padding 을 이용해 최대 자릿수만큼 앞에 **0** 을 채워주는 것이 더 좋은 방법입니다. 아래와 같이 말이죠.

~~~
0000001505202213287_zepinos
~~~

## key 기반 처리

Redis ZSET 을 이용해 랭킹(리더보드)을 구현할 때 key 의 역할은 하나의 집합을 나타내는 것으로 생각하면 됩니다. 그렇기 때문에 하나의 랭킹 집합을 초기화하거나 제거를 할 때 key 을 이용해서 지우는 것이 편합니다. 그런데, `ZSetOperations.remove()` 에는 key 와 value 을 모두 요구합니다.

### RedisOperations

앞선 글에서 **Operations 주입** 이라는 섹션이 존재합니다. 거기서 `ZSetOperations` 뿐만 아니라 `RedisOperations` 을 같이 주입 받았는데, 정작 사용한 적은 없습니다.

Redis 는 여러 형태의 데이터 타입을 제공하고 사용법이 제각각 다릅니다. 하지만 Spring Data Redis 에서는 key 기반으로 삭제거나 key 에 유효시간(TTL)을 부여하는 것 같은 부가 기능은 [RedisOperations](https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/core/RedisOperations.html "Spring Data Redis RedisOperations") 을 통해 처리할 수 있도록 되어 있습니다.

특정 랭킹(리더보드) 목록을 모두 삭제하고 싶다면 `RedisOperations.delete()` 로 삭제할 수 있고, 특정 시간에 key 을 삭제(만료)하고 싶다면 `RedisOperations.expire()` 을 이용해 예약도 가능합니다. 메모리가 충분하다면 오랜 기간 동안 랭킹(리더보드)의 기록을 계속 보관하고 있는 것도 가능하지만, 메모리는 유한하기 때문에 일정 시간이 지나면 다른 보조기억장치에 정보를 백업받고 Redis 의 랭킹(리더보드) 기록은 삭제가 되도록 구성하는 것이 일반적입니다.

## key 이름 정하기

랭킹(리더보드)을 일반적으로 사용할 때, 처음 한 번 생성하면 서비스 종료 시점까지 계속 누적시켜야 하는 경우도 있겠지만, 보통은 *일/주/월/연* 같이 주기적으로 내용을 초기화 해주고, 이전 기록에 따라 순위를 표시해주거나 보상을 자동으로 처리해줘야 하는 경우가 더 많을 것입니다.

Redis 은 앞에서 살펴봤던 것 처럼 등록 시점을 이용해서 값을 나눌 수 없고, 순수하게 같은 key 에 입력된 value 와 score 을 기준으로 정렬을 합니다. 그렇기 때문에 key 을 이용해서 이러한 기능을 만드는 것이 일반적입니다.

### key 관리 테이블

저의 경우 이러한 key 을 만들기 위한 조건을 테이블에 미리 저장을 해둡니다. key 이름만으로는 모든걸 담을 수 없을꺼라 생각하기 때문입니다.

예를 들면, 테이블에 `seq`, `name`, `period`, `order` 등의 컬럼을 만들고 `period` 에 *일/주/월/연* 중 하나의 값을 넣고, `order` 에는 *오름차순/내림차순* 중 하나의 값을 입력할 수 있도록 합니다. 이 정보를 통해 key 을 생성할 때 **LeaderBoard_(seq)_(날짜정보)** 와 같이 key 을 생성한다고 규칙을 만듭니다. 게임 등의 클라이언트에서 요청할 때에는 `seq` 만 전달해도 랭킹(리더보드) 서버에서는 자동적으로 key 을 생성할 수 있게 됩니다.

`period` 을 이용해 날짜정보를 생성하는 것은 Java 의 LocalDateTime 이나 ZonedDateTime
