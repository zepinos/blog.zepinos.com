---
layout: post
title: Spring Boot 와 Redis ZSET 을 이용한 랭킹(리더보드) 구현 - 02
author: zepinos
comments: true
category: Java
cover:  "/assets/instacode.png"
---

Redis 을 이용하면 쉽게 랭킹(리더보드)을 구현할 수 있습니다.

앞선 예제에서 봤듯이 socre 와 사용자를 구분할 수 있는 특정한 값(보통은 ID)을 value 로 하여 값을 등록하면 key 내에서 랭킹 정보를 쉽게 추출할 수 있습니다. 그게 오름차순이든 내림차순이든지 말이죠.

하지만, 단순히 이렇게 구현만 하면 해결이 되는 걸까요?

# 랭킹(리더보드)의 특성

현실 세계에서 ZSET 을 그냥 이용하기에는 약간의 문제가 있습니다. ZSET 의 잘못이라기 보다는 현실 세계의 복잡성 때문이라고 할 수 있습니다. 어떠한 것이 문제인지 다음에서 살펴보도록 하겠습니다.

## 점수 중복

보통 랭킹을 집계하다 보면 동일한 점수가 중복되어 등록될 가능성이 큽니다. 당장 스포츠에서도 많이 볼 수 있는데, 골프만 하더라도 선수들의 점수와 순위가 *몇 언더파로 공동 몇 위* 라는 식으로 표시됩니다. 여기서 *몇 언더파* 라고 하는 것이 점수에 해당하고 *공동 몇 위* 라고 하는 것이 순위에 해당합니다. 혹은 해당 점수를 우선적으로 달성한 사람이 더 앞선 순위로 표시하는 경우도 존재할 것입니다.

그런데, 아쉽게도 Redis 는 score 가 중복적으로 입력이 가능하지만, 순위를 동일하게 부여하지 않습니다. 또한 동일 점수에 대해서 우선 등록 순서에 따라서 순위를 부여하지도 않습니다.

앞에서 언급하지 않았지만, score 가 동점일 경우에는 **value** 순서대로 다시 순서를 정합니다. 입력된 시간이 기준일 것이라고 생각했을 수도 있겠지만, 그렇지 않습니다.

### 공동 순위

Redis ZSET 자체로는 공동 순위를 표시할 수 없습니다. 아쉽게도 공동 순위를 사용하고 싶다면 후처리가 필요합니다.

Redis ZSET 에서 공동 순위를 표시하기 위해 사용할 수 있는 기법은 [ZRANGEBYSCORE](https://redis.io/commands/zrevrangebyscore "Redis ZRANGEBYSCORE") 입니다. ZSetOperations 에서는 `.rangeByScore()` 로 제공됩니다(물론 역순을 위한 것도 준비되어 있습니다).

방법은 간단합니다.
 - 순위 목록을 검색
 - 목록을 이용해 loop 로 개별의 *tuple* 을 획득하여 **score** 를 알아냄
 - **score** 을 이용해 `.rangeByScore()` 에서 해당 점수 중 가장 순위가 높은 **value** 획득
 - 가장 순위가 높은 **value** 을 이용해 **rank** 획득

다만, 이렇게 구현하면 동점자가 리스트 범위 밖에도 있을 경우 한번에 동점자를 동시에 볼 수 없는 문제가 발생합니다. 이 부분은 또다시 여러가지 방법으로 해결할 방법을 고려해야 하기 때문에 여기서 언급하진 않겠습니다. 하지만, 조금만 생각해보시면 금방 해결할 수 있을꺼라 생각됩니다.

### 등록시간 기준

Redis 에서는 score 가 같을 경우 value 순서대로 정렬을 하게 됩니다. 그래서 등록시간 기준으로 동점자를 처리하고자 할 때에는 value 에 등록시간을 입력해주는 방법을 이용할 수도 있습니다.

Java 에서는 시스템 시간을 `System.currentTimeMillis()` 와 같은 명령으로 *long* 형태로 가져올 수 있습니다. 이 값을 기존 value 와 결합하면 value 를 이용해서도 두번째 정렬 기준을 이용할 수 있습니다. 물론 구분자를 통해 세번째 이상의 정렬 기준도 만들어 줄 수 있습니다.

~~~
1505202213287_zepinos
~~~

하지만, 보통의 경우에는 score 가 높은 것이 상위로 표시되도록(즉, 내림차순) 랭킹(리더보드)을 구현하는게 보통입니다. 그리고 먼저 달성한 사람이 우선일 수도 있고, 나중에 달성한 사람이 우선일 수도 있습니다.

이 경우 *long* 으로 값을 얻을 수 있다는 것에 착안하여, `Long.MAX_VALUE` 에서 차감한 값을 사용하는 방법을 고려해볼 수 있습니다. 마치 아래와 같이요.

~~~
9223370531652562520_zepinos
~~~

주의할 것은 *long* 은 숫자인데 반해, value 는 위와 같이 String 으로 정의할 경우 문자 형태로 정렬을 하기 때문에 자릿수가 올라가는 시점에서 정렬이 제대로 되지 않을 수 있습니다. 그래서 처음의 경우처럼 그냥 시스템 시간에 대한 long 값을 쓰는 것보다 padding 을 이용해 최대 자릿수만큼 앞에 **0** 을 채워주는 것이 더 좋은 방법입니다. 아래와 같이 말이죠.

~~~
0000001505202213287_zepinos
~~~
