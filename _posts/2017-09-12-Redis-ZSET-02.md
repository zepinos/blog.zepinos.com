---
layout: post
title: Spring Boot 와 Redis ZSET 을 이용한 랭킹(리더보드) 구현 - 02
author: zepinos
comments: true
category: Java
cover:  "/assets/instacode.png"
---

Redis 을 이용하면 쉽게 랭킹(리더보드)을 구현할 수 있습니다.

앞선 예제에서 봤듯이 socre 와 사용자를 구분할 수 있는 특정한 값(보통은 ID)을 value 로 하여 값을 등록하면 key 내에서 랭킹 정보를 쉽게 추출할 수 있습니다. 그게 오름차순이든 내림차순이든지 말이죠.

하지만, 단순히 이렇게 구현만 하면 해결이 되는 걸까요?

# 랭킹(리더보드)의 특성

현실 세계에서 ZSET 을 그냥 이용하기에는 약간의 문제가 있습니다. ZSET 의 잘못이라기 보다는 현실 세계의 복잡성 때문이라고 할 수 있습니다. 어떠한 것이 문제인지 다음에서 살펴보도록 하겠습니다.

## 점수 중복

보통 랭킹을 집계하다 보면 동일한 점수가 중복되어 등록될 가능성이 큽니다. 당장 스포츠에서도 많이 볼 수 있는데, 골프만 하더라도 선수들의 점수와 순위가 *몇 언더파로 공동 몇 위* 라는 식으로 표시됩니다. 여기서 *몇 언더파* 라고 하는 것이 점수에 해당하고 *공동 몇 위* 라고 하는 것이 순위에 해당합니다. 혹은 해당 점수를 우선적으로 달성한 사람이 더 앞선 순위로 표시하는 경우도 존재할 것입니다.

그런데, 아쉽게도 Redis 는 score 가 중복적으로 입력이 가능하지만, 순위를 동일하게 부여하지 않습니다. 또한 동일 점수에 대해서 우선 등록 순서에 따라서 순위를 부여하지도 않습니다.

앞에서 언급하지 않았지만, score 가 동점일 경우에는 **value** 순서대로 다시 순서를 정합니다. 입력된 시간이 기준일 것이라고 생각했을 수도 있겠지만, 그렇지 않습니다.

### 공동 순위

Redis ZSET 자체로는 공동 순위를 표시할 수 없습니다. 아쉽게도 공동 순위를 사용하고 싶다면 후처리가 필요합니다.

Redis ZSET 에서 공동 순위를 표시하기 위해 사용할 수 있는 기법은 [ZRANGEBYSCORE](https://redis.io/commands/zrevrangebyscore "Redis ZRANGEBYSCORE") 입니다. ZSetOperations 에서는 `.rangeByScore()` 로 제공됩니다(물론 역순을 위한 것도 준비되어 있습니다).

방법은 간단합니다.
 - 순위 목록을 검색
 - 목록을 이용해 loop 로 개별의 *tuple* 을 획득하여 **score** 를 알아냄
 - **score** 을 이용해 `.rangeByScore()` 에서 해당 점수 중 가장 순위가 높은 **value** 획득
 - 가장 순위가 높은 **value** 을 이용해 **rank** 획득

다만, 이렇게 구현하면 동점자가 리스트 범위 밖에도 있을 경우 한번에 동점자를 동시에 볼 수 없는 문제가 발생합니다. 이 부분은 또다시 여러가지 방법으로 해결할 방법을 고려해야 하기 때문에 여기서 언급하진 않겠습니다. 하지만, 조금만 생각해보시면 금방 해결할 수 있을꺼라 생각됩니다.

### 등록시간 기준

Redis 에서는 score 가 같을 경우 value 순서대로 정렬을 하게 됩니다. 그래서 등록시간 기준으로 동점자를 처리하고자 할 때에는 value 에 등록시간을 입력해주는 방법을 이용할 수도 있습니다.

Java 에서는 시스템 시간을 `System.currentTimeMillis()` 와 같은 명령으로 *long* 형태로 가져올 수 있습니다. 이 값을 기존 value 와 결합하면 value 를 이용해서도 두번째 정렬 기준을 이용할 수 있습니다. 물론 구분자를 통해 세번째 이상의 정렬 기준도 만들어 줄 수 있습니다.

~~~
1505202213287_zepinos
~~~

하지만, 보통의 경우에는 score 가 높은 것이 상위로 표시되도록(즉, 내림차순) 랭킹(리더보드)을 구현하는게 보통입니다. 그리고 먼저 달성한 사람이 우선일 수도 있고, 나중에 달성한 사람이 우선일 수도 있습니다.

이 경우 *long* 으로 값을 얻을 수 있다는 것에 착안하여, `Long.MAX_VALUE` 에서 차감한 값을 사용하는 방법을 고려해볼 수 있습니다. 마치 아래와 같이요.

~~~
9223370531652562520_zepinos
~~~

주의할 것은 *long* 은 숫자인데 반해, value 는 위와 같이 String 으로 정의할 경우 문자 형태로 정렬을 하기 때문에 자릿수가 올라가는 시점에서 정렬이 제대로 되지 않을 수 있습니다. 그래서 처음의 경우처럼 그냥 시스템 시간에 대한 long 값을 쓰는 것보다 padding 을 이용해 최대 자릿수만큼 앞에 **0** 을 채워주는 것이 더 좋은 방법입니다. 아래와 같이 말이죠.

~~~
0000001505202213287_zepinos
~~~

## key 기반 처리

Redis ZSET 을 이용해 랭킹(리더보드)을 구현할 때 key 의 역할은 하나의 집합을 나타내는 것으로 생각하면 됩니다. 그렇기 때문에 하나의 랭킹 집합을 초기화하거나 제거를 할 때 key 을 이용해서 지우는 것이 편합니다. 그런데, `ZSetOperations.remove()` 에는 key 와 value 을 모두 요구합니다.

### RedisOperations

앞선 글에서 **Operations 주입** 이라는 섹션이 존재합니다. 거기서 `ZSetOperations` 뿐만 아니라 `RedisOperations` 을 같이 주입 받았는데, 정작 사용한 적은 없습니다.

Redis 는 여러 형태의 데이터 타입을 제공하고 사용법이 제각각 다릅니다. 하지만 Spring Data Redis 에서는 key 기반으로 삭제거나 key 에 유효시간(TTL)을 부여하는 것 같은 부가 기능은 [RedisOperations](https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/core/RedisOperations.html "Spring Data Redis RedisOperations") 을 통해 처리할 수 있도록 되어 있습니다.

특정 랭킹(리더보드) 목록을 모두 삭제하고 싶다면 `RedisOperations.delete()` 로 삭제할 수 있고, 특정 시간에 key 을 삭제(만료)하고 싶다면 `RedisOperations.expire()` 을 이용해 예약도 가능합니다. 메모리가 충분하다면 오랜 기간 동안 랭킹(리더보드)의 기록을 계속 보관하고 있는 것도 가능하지만, 메모리는 유한하기 때문에 일정 시간이 지나면 다른 보조기억장치에 정보를 백업받고 Redis 의 랭킹(리더보드) 기록은 삭제가 되도록 구성하는 것이 일반적입니다.

## key 이름 정하기

랭킹(리더보드)을 일반적으로 사용할 때, 처음 한 번 생성하면 서비스 종료 시점까지 계속 누적시켜야 하는 경우도 있겠지만, 보통은 *일/주/월/연* 같이 주기적으로 내용을 초기화 해주고, 이전 기록에 따라 순위를 표시해주거나 보상을 자동으로 처리해줘야 하는 경우가 더 많을 것입니다.

Redis 은 앞에서 살펴봤던 것 처럼 등록 시점을 이용해서 값을 나눌 수 없고, 순수하게 같은 key 에 입력된 value 와 score 을 기준으로 정렬을 합니다. 그렇기 때문에 key 을 이용해서 이러한 기능을 만드는 것이 일반적입니다.

### key 관리 테이블

저의 경우 이러한 key 을 만들기 위한 조건을 테이블에 미리 저장을 해둡니다. key 이름만으로는 모든걸 담을 수 없을꺼라 생각하기 때문입니다.

예를 들면, 테이블에 `seq`, `name`, `period`, `order` 등의 컬럼을 만들고 `period` 에 *일/주/월/연* 중 하나의 값을 넣고, `order` 에는 *오름차순/내림차순* 중 하나의 값을 입력할 수 있도록 합니다. 이 정보를 통해 key 을 생성할 때 **LeaderBoard_(seq)_(날짜정보)** 와 같이 key 을 생성한다고 규칙을 만듭니다. 게임 등의 클라이언트에서 요청할 때에는 `seq` 만 전달해도 랭킹(리더보드) 서버에서는 자동적으로 key 을 생성할 수 있게 됩니다.

### Java 을 이용한 key 생성

`period` 을 이용해 날짜정보를 생성하는 것은 Java 8 에서 추가된 `LocalDateTime` 을 이용하면 원하는 형태대로 추출할 수 있는데, `LocalDateTime.format()` 을 이용해 `DateTimeFormatter.ofPattern()` 을 이용하면 *yyyy-MM-dd* 나 *YYYY-ww* 같이 적절한 문자열을 생성할 수 있습니다.

~~~java
// 현재 시각(UTC 기준) 객체 생성
LocalDateTime localDateTime = LocalDateTime.now(ZoneOffset.UTC);

// 현재 시각을 "YYYY년 ww주" 형태(week of year)의 문자열로 변환 
String currentDate = localDateTime.format(DateTimeFormatter.ofPattern("YYYY-ww"));
~~~

Java 을 이용할 때 주의할 점은 Java 의 기존 `java.util.Date` 는 주 단위의 정보를 취급할 때 부적절하다는 것입니다.
*연/월/일* 같이 계산 자체가 필요없는 형태의 데이터와는 달리 해당 날짜가 몇 년도 몇 주차에 해당하는지에 대한 계산 방법은 ISO 표준이 존재하긴 하지만 실질적으로 나라마다 관습적으로 다르게 사용하고 있습니다.
뿐만 아니라 게임 등에선 일요일 혹은 월요일 기준으로 모든 랭킹(리더보드) 정보를 초기화하지 않고 주중(즉, 수요일이나 목요일)이 집계의 마감이 이루어지고 초기화가 이루어지는 시점이 될 수 있습니다. 그런데 `java.util.Date` 에는 시작 주를 바꾸는 기능이 존재하지만 내부 코드의 버그로 인해 해가 바뀔 때 엉뚱한 오류가 발생하기도 합니다(실제 **경험담**).

Java 에는 오랜 기간 동안 문제가 많음을 인지하고 있으나 고쳐지지 않았던 Class 들이 몇 개 존재했는데, 이 `java.util.Date` 도 그 중의 하나였습니다.
Java 8 에서는 `java.time` 패키지에 `LocalDateTime` 와 같은 Class 을 구현하였습니다(JSR-310).
이러한 구현체들은 **ISO-8601 캘린더 시스템** 을 구현한 것입니다.
Java 8 이전 버전에서는 이용할 수 없지만, `java.time` 에 영향을 끼친 [Joda-Time](http://www.joda.org/joda-time/) 을 이용하면 유사한 형태로 key 로 사용할 날짜 문자열을 생성할 수 있습니다.

이렇게 생성한 날짜 정보를 key 에 추가하면, 매주마다 seq 별로 새로운 key 가 하나씩 생겨나게 될것입니다. 이 글을 적는 시점이 2017년 9월 12일이므로 `LeaderBoard_1_2017-37` 처럼 말이죠.
물론 2017년 9월 14일에 다른 value 와 score 을 입력한다고 해도 `LeaderBoard_1_2017-37` 에 추가될 것입니다.
하지만 2017년 9월 19일에 새로운 값이 추가된다면 `LeaderBoard_1_2017-38` 이라는 새로운 key 에 값이 추가되겠죠.

다른 특별한 조작 없이도 매주 랭킹(리더보드)이 갱신되고, 새로운 key 가 발급된 후 천천히 지난 key 에 대한 최종 정보를 백업받고 후처리(보상 산정 등)를 진행하면 됩니다.   

## score 정렬 방식에 따른 value 생성

value 에는 단순히 id 같은 사용자의 `primary key` 에 해당하는 것을 저장해도 되지만, 앞서 말했듯이 정렬의 두번째 조건이 되기 때문에 입력 시간과 같은 두번째 정렬 조건을 *접두어* 같이 구분자와 함께 연결하여 사용하는 것이 낫다고 하였습니다.
그런데, 보통 하나의 랭킹(리더보드)을 생성하는 경우 무조건 그에 맞게 시간 정보를 생성해서 연결하면 되지만, 어떤 랭킹이냐에 따라 오름차순 혹은 내림차순을 해야하는 것이 있을 것입니다. 그리고, 대체적으로 먼저 입력된 쪽이 랭킹상 앞서야 하겠죠. 그래서 앞서 말한 key 테이블에 `order` 정보를 저장해두고 score 을 새로 등록하려고 할 때 value 에 시간 정보(long)을 그대로 넣을 것인지, 뒤집어서 넣을 것인지 판단해서 넣어야 합니다.

### 사용자의 중복 저장 문제

value 에 두 개 이상의 정보를 구분자를 이용해 복합적으로 저장할 경우 
